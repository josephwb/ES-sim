?rep()
plot()
plot.new()
new.var1 <- cbind(rep("blood", length(var1)), var1)
var1 <- c(1,2,3,5,4,6,1,3)
new.var1 <- cbind(rep("blood", length(var1)), var1)
new.var1
colnames(new.var1) <- c("tissue", "value")
new.var1
var1 <- c(1,2,3,5,4,6,1,3)#
var2 <- c(1,8,4,3,2,2,1,3)#
new.var1 <- cbind(rep("blood", length(var1)), var1)#
new.var2 <- cbind(rep("blood", length(var2)), var2)#
new.all <- rbind(new.var1, new.var2)
colnames(new.all) <- c("tissue", "value")
new.all
var1 <- c(1,2,3,5,4,6,1,3)#
var2 <- c(1,8,4,3,2,2,1,3)#
new.var1 <- cbind(rep("blood", length(var1)), var1)#
new.var2 <- cbind(rep("feather", length(var2)), var2)#
new.all <- rbind(new.var1, new.var2)#
colnames(new.all) <- c("tissue", "value")#
new.all
boxplot(new.all$value~new.all$tissue)
boxplot(new.all[,1]~new.all[,2])
new.all[,1]
var1 <- c(1,2,3,5,4,6,1,3)
var1
new.var1 <- cbind(rep("blood", length(var1)), var1)
new.var1
var1 <- c(1,2,3,5,4,6,1,3)#
var2 <- c(1,8,4,3,2,2,1,3)#
new.var1 <- cbind(rep("blood", length(var1)), as.numeric(var1))#
new.var2 <- cbind(rep("feather", length(var2)), as.numeric(var2))#
new.all <- rbind(new.var1, new.var2)#
colnames(new.all) <- c("tissue", "value")#
new.all#
boxplot(new.all[,1]~new.all[,2])
new.var1
new.var1 <- cbind(rep("blood", length(var1)), as.vector(var1))
new.var1
boxplot(as.numeric(new.all[,2])~new.all[,1])
boxplot(as.numeric(new.all$tissue)~new.all[,1])
var1 <- c(1,2,3,5,4,6,1,3)#
var2 <- c(1,8,4,3,2,2,1,3)#
new.var1 <- cbind(rep("blood", length(var1)), var1)#
new.var2 <- cbind(rep("feather", length(var2)), var2)#
new.all <- rbind(new.var1, new.var2)#
colnames(new.all) <- c("tissue", "value")#
new.all#
boxplot(as.numeric(new.all[,2])~new.all[,1])
?var.test()
?Hmisc
Hmisc
citation(Hmisc)
library(Hmisc)
citation(Hmisc)
citation(package="Hmisc")
devtools::install_github('bomeara/phrapl')
devtools::install_github('bomeara/phrapl', force=TRUE)
remove.packages('phrapl')
devtools::install_github('bomeara/phrapl')
remove.packages('phrapl')
devtools::install_github('bomeara/phrapl')
library('phrapl')
phrapl
install.packages( #
    lib  = lib <- .libPaths()[1],#
    pkgs = as.data.frame(installed.packages(lib), stringsAsFactors=FALSE)$Package,#
    type = 'source'#
)
install.packages(ape)
install.packages("ape")
install.packages("caper")
install.packages("diversitree")
install.packages("phytools")
install.packages("geiger")
pca
pcomp
prcomp
?prcomp()
citation(stats)
citation("stats")
=70+(*8*37)
=70+(8*37)
70+(8*37)
citation(maptools)
library(maptools)
library(rgdal)
library(raster)
library(GIStools)
library(rgeos)
library(spThin)
library(mapplots)
?readOGR
?readShapeSpatial
?raster()
?projection()
?extract()
library(raster)#
library(maptools)#
library(RColorBrewer)#
library(mapplots)#
library(GISTools)#
library(nnet)#
library(rgdal)#
library(sp)#
library(rgeos)#
library(spThin)
?extract()
?projec4string()
?proj4string()
?coordinates()
citation(maptools)
library(maptools)
citation(maptools)
citation("maptools")
citation("raster")
citation("rgdal")
citation("spThin")
source("essim.R")
setwd("/Users/michaelharvey/git/ES-sim")
getwd()
source("essim.R")
trees250sdd <- read.tree("trees250sdd.txt")
library(ape)
trees250sdd <- read.tree("trees250sdd.txt")
states250sdd <- read.table("trees250sdd_states.txt", header=TRUE, row.names=1)
i <- 1
trait <- states250sdd[,i]
names(trait) <- row.names(states250sdd)
phy <- trees250sdd[[i]]
dframe <- data.frame(names(trait), trait, log(is[as.vector(names(trait))]))
trait
dframe <- data.frame(names(trait), trait, log(is[as.vector(names(trait))]))
rootnode <- length(phy$tip.label) + 1#
		is <- numeric(length(phy$tip.label))#
		for (i in 1:length(is)){#
			node <- i#
			index <- 1#
			qx <- 0#
			while (node != rootnode){#
				el <- phy$edge.length[phy$edge[,2] == node]#
				node <- phy$edge[,1][phy$edge[,2] == node]			#
				qx <- qx + el* (1 / 2^(index-1))			#
				index <- index + 1#
			}#
			is[i] <- 1/qx#
		}		#
	names(is) <- phy$tip.label
dframe <- data.frame(names(trait), trait, log(is[as.vector(names(trait))]))
colnames(dframe) <- c("species", "trait", "invsplits")
data <- comparative.data(data=dframe, phy=phy, names.col="species")
require(caper)
data <- comparative.data(data=dframe, phy=phy, names.col="species")
q.trait <- fitContinuous(data$phy, trait, model="BM")#
	rate <- q.trait$opt$sigsq#
	root <- q.trait$opt$z0#
	rate#
	root
library(geiger)
q.trait <- fitContinuous(data$phy, trait, model="BM")#
	rate <- q.trait$opt$sigsq#
	root <- q.trait$opt$z0#
	rate#
	root
vv <- vcv.phylo(as.phylo(data$phy))#
	vmat <- vmat * lambda#
	diag(vmat) <- dd#
	onev <- matrix(rep(1, length(traits)), nrow=length(trait), ncol=1)#
	root <- as.vector(solve(t(onev)%*% solve(vmat) %*% onev) %*% (t(onev)%*% solve(vmat) %*% traits))#
	rate <- as.vector((t(traits-anc) %*% solve(vmat) %*% (traits-anc))/length(traits))#
	loglik <- dmvnorm(traits, mean=rep(anc, nrow(vmat)), sigma=vmat*beta, log=T)#
	rate#
	root
vmat <- vcv.phylo(as.phylo(data$phy))
vmat <- vmat * lambda#
	diag(vmat) <- dd#
	onev <- matrix(rep(1, length(traits)), nrow=length(trait), ncol=1)#
	root <- as.vector(solve(t(onev)%*% solve(vmat) %*% onev) %*% (t(onev)%*% solve(vmat) %*% traits))#
	rate <- as.vector((t(traits-anc) %*% solve(vmat) %*% (traits-anc))/length(traits))#
	loglik <- dmvnorm(traits, mean=rep(anc, nrow(vmat)), sigma=vmat*beta, log=T)#
	rate#
	root
vmat <- vcv.phylo(as.phylo(data$phy))#
	diag(vmat) <- dd#
	onev <- matrix(rep(1, length(traits)), nrow=length(trait), ncol=1)#
	root <- as.vector(solve(t(onev)%*% solve(vmat) %*% onev) %*% (t(onev)%*% solve(vmat) %*% traits))#
	rate <- as.vector((t(traits-anc) %*% solve(vmat) %*% (traits-anc))/length(traits))#
	loglik <- dmvnorm(traits, mean=rep(anc, nrow(vmat)), sigma=vmat*beta, log=T)#
	rate#
	root
dd <- diag(vmat)
dd <- diag(vmat)#
	vmat <- vcv.phylo(as.phylo(data$phy))#
	diag(vmat) <- dd#
	onev <- matrix(rep(1, length(traits)), nrow=length(trait), ncol=1)#
	root <- as.vector(solve(t(onev)%*% solve(vmat) %*% onev) %*% (t(onev)%*% solve(vmat) %*% traits))#
	rate <- as.vector((t(traits-anc) %*% solve(vmat) %*% (traits-anc))/length(traits))#
	loglik <- dmvnorm(traits, mean=rep(anc, nrow(vmat)), sigma=vmat*beta, log=T)#
	rate#
	root
# Fit Brownian motion model to get diffusion rate and root state estimates using GEIGER#
	dd <- diag(vmat)#
	vmat <- vcv.phylo(as.phylo(data$phy))#
	diag(vmat) <- dd#
	onev <- matrix(rep(1, length(trait)), nrow=length(trait), ncol=1)#
	root <- as.vector(solve(t(onev)%*% solve(vmat) %*% onev) %*% (t(onev)%*% solve(vmat) %*% trait))#
	rate <- as.vector((t(trait-anc) %*% solve(vmat) %*% (trait-anc))/length(trait))#
	loglik <- dmvnorm(trait, mean=rep(anc, nrow(vmat)), sigma=vmat*beta, log=T)#
	rate#
	root
dd <- diag(vmat)#
	vmat <- vcv.phylo(as.phylo(data$phy))#
	diag(vmat) <- dd#
	onev <- matrix(rep(1, length(trait)), nrow=length(trait), ncol=1)#
	root <- as.vector(solve(t(onev)%*% solve(vmat) %*% onev) %*% (t(onev)%*% solve(vmat) %*% trait))#
	rate <- as.vector((t(trait-root) %*% solve(vmat) %*% (trait-root))/length(trait))#
	loglik <- dmvnorm(trait, mean=rep(root, nrow(vmat)), sigma=vmat*beta, log=T)#
	rate#
	root
# Fit Brownian motion model to get diffusion rate and root state estimates using GEIGER#
	dd <- diag(vmat)#
	vmat <- vcv.phylo(as.phylo(data$phy))#
	diag(vmat) <- dd#
	onev <- matrix(rep(1, length(trait)), nrow=length(trait), ncol=1)#
	root <- as.vector(solve(t(onev)%*% solve(vmat) %*% onev) %*% (t(onev)%*% solve(vmat) %*% trait))#
	rate <- as.vector((t(trait-root) %*% solve(vmat) %*% (trait-root))/length(trait))#
	rate#
	root
q.trait <- fitContinuous(data$phy, trait, model="BM")#
	rate <- q.trait$opt$sigsq#
	root <- q.trait$opt$z0#
	rate#
	root
?diag()
vmat <- vcv.phylo(as.phylo(data$phy))
dd <- diag(vmat)
diag(vmat) <- dd
diag(vmat)
vmat <- vcv.phylo(as.phylo(data$phy))
vmat
class(phy)
dd <- diag(vmat)
vmat <- vcv.phylo(as.phylo(data$phy))#
	dd <- diag(vmat)#
#
	onev <- matrix(rep(1, length(trait)), nrow=length(trait), ncol=1)#
	root <- as.vector(solve(t(onev)%*% solve(vmat) %*% onev) %*% (t(onev)%*% solve(vmat) %*% trait))#
	rate <- as.vector((t(trait-root) %*% solve(vmat) %*% (trait-root))/length(trait))#
	rate#
	root
# compute analytical solution for Brownian rate parameter#
phylogeneticMean <- function(traits, phy, lambda=1){#
	if (!is.null(names(traits)))#
		traits <- traits[phy$tip.label];#
	if (class(phy) == 'phylo'){#
		vmat <- vcv.phylo(phy);			#
	}else{#
		vmat <- phy;#
	}#
	dd <- diag(vmat);#
	vmat <- vmat * lambda;#
	diag(vmat) <- dd;#
	onev <- matrix(rep(1, length(traits)), nrow=length(traits), ncol=1);#
#
	anc <- as.vector(solve(t(onev)%*% solve(vmat) %*% onev) %*% (t(onev)%*% solve(vmat) %*% traits));#
	beta <- as.vector((t(traits-anc) %*% solve(vmat) %*% (traits-anc))/length(traits));#
	loglik <- dmvnorm(traits, mean=rep(anc, nrow(vmat)), sigma=vmat*beta, log=T);	#
	return(list(anc=as.vector(anc), beta=as.vector(beta), loglik = loglik));#
#
}
phylogeneticMean(trait, data$phy, lambda=1)
q.trait <- fitContinuous(data$phy, trait, model="BM")#
	rate <- q.trait$opt$sigsq#
	root <- q.trait$opt$z0#
	rate#
	root
if (!is.null(names(traits)))#
		traits <- traits[phy$tip.label];#
	if (class(phy) == 'phylo'){#
		vmat <- vcv.phylo(phy);			#
	}else{#
		vmat <- phy;#
	}#
	dd <- diag(vmat);#
	vmat <- vmat * lambda;#
	diag(vmat) <- dd;#
	onev <- matrix(rep(1, length(traits)), nrow=length(traits), ncol=1);#
#
	anc <- as.vector(solve(t(onev)%*% solve(vmat) %*% onev) %*% (t(onev)%*% solve(vmat) %*% traits));#
	beta <- as.vector((t(traits-anc) %*% solve(vmat) %*% (traits-anc))/length(traits));
traits <- trait
lambda = 1
if (!is.null(names(traits)))#
		traits <- traits[phy$tip.label];#
	if (class(phy) == 'phylo'){#
		vmat <- vcv.phylo(phy);			#
	}else{#
		vmat <- phy;#
	}#
	dd <- diag(vmat);#
	vmat <- vmat * lambda;#
	diag(vmat) <- dd;#
	onev <- matrix(rep(1, length(traits)), nrow=length(traits), ncol=1);#
#
	anc <- as.vector(solve(t(onev)%*% solve(vmat) %*% onev) %*% (t(onev)%*% solve(vmat) %*% traits));#
	beta <- as.vector((t(traits-anc) %*% solve(vmat) %*% (traits-anc))/length(traits));
anc
beta
dd <- diag(vmat);#
	vmat <- vmat * lambda;#
	diag(vmat) <- dd;#
	onev <- matrix(rep(1, length(traits)), nrow=length(traits), ncol=1);#
#
	anc <- as.vector(solve(t(onev)%*% solve(vmat) %*% onev) %*% (t(onev)%*% solve(vmat) %*% traits));#
	beta <- as.vector((t(traits-anc) %*% solve(vmat) %*% (traits-anc))/length(traits));
anc
beta
# Fit Brownian motion model to get diffusion rate and root state estimates using GEIGER#
	dd <- diag(vmat);#
	vmat <- vmat * lambda;#
	diag(vmat) <- dd;#
	onev <- matrix(rep(1, length(traits)), nrow=length(traits), ncol=1);#
#
	root <- as.vector(solve(t(onev)%*% solve(vmat) %*% onev) %*% (t(onev)%*% solve(vmat) %*% traits));#
	rate <- as.vector((t(traits-root) %*% solve(vmat) %*% (traits-root))/length(traits));#
	rate
root
# Fit Brownian motion model to get diffusion rate and root state estimates using GEIGER#
	dd <- diag(vmat);#
	vmat <- vmat * lambda;#
	diag(vmat) <- dd;#
	onev <- matrix(rep(1, length(trait)), nrow=length(trait), ncol=1);#
#
	root <- as.vector(solve(t(onev)%*% solve(vmat) %*% onev) %*% (t(onev)%*% solve(vmat) %*% trait));#
	rate <- as.vector((t(trait-root) %*% solve(vmat) %*% (trait-root))/length(trait));#
	rate#
	root
# Fit Brownian motion model to get diffusion rate and root state estimates using GEIGER#
	dd <- diag(vmat);#
	vmat <- vmat * lambda;#
	diag(vmat) <- dd;#
	onev <- matrix(rep(1, length(traits)), nrow=length(traits), ncol=1);#
#
	root <- as.vector(solve(t(onev)%*% solve(vmat) %*% onev) %*% (t(onev)%*% solve(vmat) %*% traits));#
	rate <- as.vector((t(traits-root) %*% solve(vmat) %*% (trait-root))/length(traits));#
	rate#
	root
# Make phylo comparative data object with trait and inverse splits stat for each species#
	dframe <- data.frame(names(trait), trait, log(is[as.vector(names(trait))]))#
	colnames(dframe) <- c("species", "trait", "invsplits")#
	data <- comparative.data(data=dframe, phy=phy, names.col="species")#
#
	# Fit Brownian motion model to get diffusion rate and root state estimates using GEIGER#
	dd <- diag(vmat);#
	vmat <- vmat * lambda;#
	diag(vmat) <- dd;#
	onev <- matrix(rep(1, length(traits)), nrow=length(traits), ncol=1);#
#
	root <- as.vector(solve(t(onev)%*% solve(vmat) %*% onev) %*% (t(onev)%*% solve(vmat) %*% traits));#
	rate <- as.vector((t(traits-root) %*% solve(vmat) %*% (traits-root))/length(traits));#
	rate#
	root
trait
traits
trait
traits
q.trait <- fitContinuous(data$phy, trait, model="BM")#
	rate <- q.trait$opt$sigsq#
	root <- q.trait$opt$z0#
	rate#
	root
trait
traits
names(traits)
names(triat)
names(trait)
trait <- states250sdd[,i]
trees250sdd <- read.tree("trees250sdd.txt")
states250sdd <- read.table("trees250sdd_states.txt", header=TRUE, row.names=1)
trait <- states250sdd[,i]
i <- 1
trait <- states250sdd[,i]
trait
names(trait) <- row.names(states250sdd)
trait
phy$tip.label
trait <- trait[phy$tip.label]
trait
vmat <- vmat * lambda	#
	onev <- matrix(rep(1, length(trait)), nrow=length(trait), ncol=1);#
	root <- as.vector(solve(t(onev)%*% solve(vmat) %*% onev) %*% (t(onev)%*% solve(vmat) %*% traits));#
	rate <- as.vector((t(traits-root) %*% solve(vmat) %*% (traits-root))/length(traits));#
	rate#
	root
setwd("/Users/michaelharvey/git/ES-sim")#
getwd()#
#
library(ape)#
#
# Power test#
#
trees250sdd <- read.tree("trees250sdd.txt")#
states250sdd <- read.table("trees250sdd_states.txt", header=TRUE, row.names=1)#
#
i <- 1#
trait <- states250sdd[,i]#
names(trait) <- row.names(states250sdd)#
phy <- trees250sdd[[i]]#
#
source("essim.R")#
#
essim(trees250sdd[[i]], trait, nsim = 1000)
nsim = 1000
phy <- trees250sdd[[i]]
if(missing(is)) { # If inverse equal splits statistics not provided, calculate it#
		rootnode <- length(phy$tip.label) + 1#
		is <- numeric(length(phy$tip.label))#
		for (i in 1:length(is)){#
			node <- i#
			index <- 1#
			qx <- 0#
			while (node != rootnode){#
				el <- phy$edge.length[phy$edge[,2] == node]#
				node <- phy$edge[,1][phy$edge[,2] == node]			#
				qx <- qx + el* (1 / 2^(index-1))			#
				index <- index + 1#
			}#
			is[i] <- 1/qx#
		}		#
	names(is) <- phy$tip.label#
	}
rootnode <- length(phy$tip.label) + 1#
		is <- numeric(length(phy$tip.label))#
		for (i in 1:length(is)){#
			node <- i#
			index <- 1#
			qx <- 0#
			while (node != rootnode){#
				el <- phy$edge.length[phy$edge[,2] == node]#
				node <- phy$edge[,1][phy$edge[,2] == node]			#
				qx <- qx + el* (1 / 2^(index-1))			#
				index <- index + 1#
			}#
			is[i] <- 1/qx#
		}		#
	names(is) <- phy$tip.label
is <- is[phy$tip.label]#
	trait <- trait[phy$tip.label]
# Pearson's correlation between splits statistic and trait#
	res <- cor.test(is, trait, method="pearson")#
#
	# Fit Brownian motion model to get diffusion rate and root state estimates#
	vv <- vcv.phylo(as.phylo(data$phy))#
	onev <- matrix(rep(1, length(trait)), nrow=length(trait), ncol=1)#
	root <- as.vector(solve(t(onev)%*% solve(vv) %*% onev) %*% (t(onev)%*% solve(vv) %*% traits))#
	rate <- as.vector((t(traits-root) %*% solve(vv) %*% (traits-root))/length(traits))
vv <- vcv.phylo(as.phylo(phy))
onev <- matrix(rep(1, length(trait)), nrow=length(trait), ncol=1)#
	root <- as.vector(solve(t(onev)%*% solve(vv) %*% onev) %*% (t(onev)%*% solve(vv) %*% traits))#
	rate <- as.vector((t(traits-root) %*% solve(vv) %*% (traits-root))/length(traits))
root <- as.vector(solve(t(onev)%*% solve(vv) %*% onev) %*% (t(onev)%*% solve(vv) %*% trait))#
	rate <- as.vector((t(trait-root) %*% solve(vv) %*% (trait-root))/length(trait))
root
rate
# Brownian simulations #
	sims <- t(rmvnorm(nsim, sigma=rate*vv))#
	rownames(sims) <- rownames(vv)#
	# Pearson's correlations of simulated datasets#
	sim.r <- sapply(1:nsim, function(x) cor.test(log(is[as.vector(rownames(sims))]), sims[,x], method="pearson")$estimate)#
	# Calculate the two-tailed p value#
	corr <- res$estimate#
	upper <- length(sim.r[sim.r >= corr])/nsim#
	lower <- length(sim.r[sim.r <= corr])/nsim#
	pval <- 2*min(c(upper,lower)) # Remove "2" for one-tailed#
#
	result <- as.vector(c(corr, pval))#
	names(result) <- c("rho", "P Value")#
	return(result)
require(mvtnorm)
# Brownian simulations #
	sims <- t(rmvnorm(nsim, sigma=rate*vv))#
	rownames(sims) <- rownames(vv)#
	# Pearson's correlations of simulated datasets#
	sim.r <- sapply(1:nsim, function(x) cor.test(log(is[as.vector(rownames(sims))]), sims[,x], method="pearson")$estimate)#
	# Calculate the two-tailed p value#
	corr <- res$estimate#
	upper <- length(sim.r[sim.r >= corr])/nsim#
	lower <- length(sim.r[sim.r <= corr])/nsim#
	pval <- 2*min(c(upper,lower)) # Remove "2" for one-tailed#
#
	result <- as.vector(c(corr, pval))#
	names(result) <- c("rho", "P Value")#
	return(result)
source("essim.R")
essim(trees250sdd[[i]], trait, nsim = 1000)
setwd("/Users/michaelharvey/git/ES-sim")#
getwd()#
#
library(ape)#
#
# Power test#
#
trees250sdd <- read.tree("trees250sdd.txt")#
states250sdd <- read.table("trees250sdd_states.txt", header=TRUE, row.names=1)#
#
i <- 1#
trait <- states250sdd[,i]#
names(trait) <- row.names(states250sdd)#
phy <- trees250sdd[[i]]#
#
source("essim.R")#
#
essim(trees250sdd[[i]], trait, nsim = 1000)
source("essim2.R")
essim(trees250sdd[[i]], trait, nsim = 1000)
source("essim.R")
essim(trees250sdd[[i]], trait, nsim = 1000)
source("essim2.R")
essim(trees250sdd[[i]], trait, nsim = 1000)
require(ape)#
	require(mvtnorm)#
	if(missing(is)) { # If inverse equal splits statistics not provided, calculate it#
		rootnode <- length(phy$tip.label) + 1#
		is <- numeric(length(phy$tip.label))#
		for (i in 1:length(is)){#
			node <- i#
			index <- 1#
			qx <- 0#
			while (node != rootnode){#
				el <- phy$edge.length[phy$edge[,2] == node]#
				node <- phy$edge[,1][phy$edge[,2] == node]			#
				qx <- qx + el* (1 / 2^(index-1))			#
				index <- index + 1#
			}#
			is[i] <- 1/qx#
		}		#
	names(is) <- phy$tip.label#
	}#
	is <- is[phy$tip.label]#
	trait <- trait[phy$tip.label]#
	# Pearson's correlation between splits statistic and trait#
	res <- cor.test(is, trait, method="pearson")#
#
	# Fit Brownian motion model to get diffusion rate and root state estimates#
	vv <- vcv.phylo(as.phylo(phy))#
	onev <- matrix(rep(1, length(trait)), nrow=length(trait), ncol=1)#
	root <- as.vector(solve(t(onev)%*% solve(vv) %*% onev) %*% (t(onev)%*% solve(vv) %*% trait))#
	rate <- as.vector((t(trait-root) %*% solve(vv) %*% (trait-root))/length(trait))
root
rate
require(ape)#
	require(caper)#
	require(geiger)#
	if(missing(is)) { # If inverse splits statistics not provided, calculate it#
		rootnode <- length(phy$tip.label) + 1#
		is <- numeric(length(phy$tip.label))#
		for (i in 1:length(is)){#
			node <- i#
			index <- 1#
			qx <- 0#
			while (node != rootnode){#
				el <- phy$edge.length[phy$edge[,2] == node]#
				node <- phy$edge[,1][phy$edge[,2] == node]			#
				qx <- qx + el* (1 / 2^(index-1))			#
				index <- index + 1#
			}#
			is[i] <- 1/qx#
		}		#
	names(is) <- phy$tip.label#
	}#
	# Make phylo comparative data object with trait and inverse splits stat for each species#
	dframe <- data.frame(names(trait), trait, log(is[as.vector(names(trait))]))#
	colnames(dframe) <- c("species", "trait", "invsplits")#
	data <- comparative.data(data=dframe, phy=phy, names.col="species")#
#
	# Fit Brownian motion model to get diffusion rate and root state estimates using GEIGER#
	q.trait <- fitContinuous(data$phy, trait, model="BM")#
	rate <- q.trait$opt$sigsq#
	root <- q.trait$opt$z0
root
rate
res
res <- cor.test(data$data$invsplits, data$data$trait, method="pearson")
res
data$data$invsplits
is
trait
source("essim.R")
essim(trees250sdd[[i]], trait, nsim = 1000)
is <- log(is[phy$tip.label]) # log transform
trait <- trait[phy$tip.label]
res <- cor.test(is, trait, method="pearson")
vv <- vcv.phylo(as.phylo(phy))#
	onev <- matrix(rep(1, length(trait)), nrow=length(trait), ncol=1)#
	root <- as.vector(solve(t(onev)%*% solve(vv) %*% onev) %*% (t(onev)%*% solve(vv) %*% trait))#
	rate <- as.vector((t(trait-root) %*% solve(vv) %*% (trait-root))/length(trait))
# Brownian simulations #
	sims <- t(rmvnorm(nsim, sigma=rate*vv))#
	rownames(sims) <- rownames(vv)#
	# Pearson's correlations of simulated datasets#
	sim.r <- sapply(1:nsim, function(x) cor.test(log(is[as.vector(rownames(sims))]), sims[,x], method="pearson")$estimate)
sim.r <- sapply(1:nsim, function(x) cor.test(is[as.vector(rownames(sims)]), sims[,x], method="pearson")$estimate)
sim.r <- sapply(1:nsim, function(x) cor.test(is[as.vector(rownames(sims))], sims[,x], method="pearson")$estimate)
corr <- res$estimate#
	upper <- length(sim.r[sim.r >= corr])/nsim#
	lower <- length(sim.r[sim.r <= corr])/nsim#
	pval <- 2*min(c(upper,lower)) # Remove "2" for one-tailed#
#
	result <- as.vector(c(corr, pval))#
	names(result) <- c("rho", "P Value")#
	return(result)
source("essim.R")
essim(trees250sdd[[i]], trait, nsim = 1000)
is
data$data$invsplits
is[as.vector(rownames(sims))]
rownames(vv)
phy$tip.label
source("essim.R")
essim(trees250sdd[[i]], trait, nsim = 1000)
source("essim2.R")
essim(trees250sdd[[i]], trait, nsim = 1000)
setwd("/Users/michaelharvey/git/ES-sim")#
getwd()#
#
library(ape)#
#
# Power test#
#
trees250sdd <- read.tree("trees250sdd.txt")#
states250sdd <- read.table("trees250sdd_states.txt", header=TRUE, row.names=1)#
#
i <- 1#
trait <- states250sdd[,i]#
names(trait) <- row.names(states250sdd)#
phy <- trees250sdd[[i]]#
#
source("essim.R")#
#
essim(trees250sdd[[i]], trait, nsim = 1000)#
phy <- trees250sdd[[i]]
setwd("/Users/michaelharvey/git/ES-sim")#
getwd()#
#
library(ape)#
#
# Power test#
#
trees250sdd <- read.tree("trees250sdd.txt")#
states250sdd <- read.table("trees250sdd_states.txt", header=TRUE, row.names=1)#
#
i <- 1#
trait <- states250sdd[,i]#
names(trait) <- row.names(states250sdd)#
phy <- trees250sdd[[i]]#
#
source("essim2.R")#
#
essim(trees250sdd[[i]], trait, nsim = 1000)#
phy <- trees250sdd[[i]]
essim(trees250sdd[[i]], trait, nsim = 1000)
essim(trees250sdd[[i]], trait, nsim = 1000)
essim(trees250sdd[[i]], trait, nsim = 1000)
essim(trees250sdd[[i]], trait, nsim = 1000)
essim(trees250sdd[[i]], trait, nsim = 1000)
essim(trees250sdd[[i]], trait, nsim = 1000)
essim(trees250sdd[[i]], trait, nsim = 1000)
essim(trees250sdd[[i]], trait, nsim = 1000)
essim(trees250sdd[[i]], trait, nsim = 1000)
essim(trees250sdd[[i]], trait, nsim = 1000)
essim(trees250sdd[[i]], trait, nsim = 1000)
essim(trees250sdd[[i]], trait, nsim = 1000)
essim(trees250sdd[[i]], trait, nsim = 1000)
essim(trees250sdd[[i]], trait, nsim = 1000)
essim(trees250sdd[[i]], trait, nsim = 1000)
essim(trees250sdd[[i]], trait, nsim = 1000)
essim(trees250sdd[[i]], trait, nsim = 1000)
essim(trees250sdd[[i]], trait, nsim = 1000)
essim(trees250sdd[[i]], trait, nsim = 1000)
essim(trees250sdd[[i]], trait, nsim = 1000)
